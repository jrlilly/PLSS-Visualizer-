<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>PLSS Grid</title>
<style>
  body {
    background-color: #F1E9D2; /* parchment */
    display: flex;
    justify-content: center;
    align-items: center;
    height: 100vh;
    margin: 0;
    font-family: Arial, sans-serif;
  }
  #container {
    text-align: center;
  }
  #grid {
    position: relative;
    display: grid;
    grid-template-columns: repeat(16, 30px);
    grid-template-rows: repeat(16, 30px);
    gap: 1px;
    background-color: #c2b280;
    margin: 20px auto;
    width: max-content;
    border: 2px solid #333;
  }
  .cell {
    background-color: white;
    border: 1px solid #999;
    cursor: pointer;
    box-sizing: border-box;
  }
  .cell.selected {
    background-color: #00FFFF;
    color: white;
  }
  /* Border styles */
  .border-top {
    border-top: 3px solid #333;
  }
  .border-left {
    border-left: 3px solid #333;
  }
  .border-bottom {
    border-bottom: 3px solid #333;
  }
  .border-right {
    border-right: 3px solid #333;
  }
  /* Main subgrid lines */
  .subgrid-line {
    position: absolute;
    background-color: black;
    z-index: 2;
  }
  /* Vertical main subgrid lines at 8 cells (half) */
  .subgrid-v1 {
    left: calc(8 * 31px - 1px);
    top: 0;
    width: 3px;
    height: 100%;
  }
  .subgrid-v2 {
    left: calc(16 * 31px - 1px);
    top: 0;
    width: 3px;
    height: 100%;
  }
  /* Horizontal main subgrid lines at 8 cells */
  .subgrid-h1 {
    top: calc(8 * 31px - 1px);
    left: 0;
    height: 3px;
    width: 100%;
  }
  .subgrid-h2 {
    top: calc(16 * 31px - 1px);
    left: 0;
    height: 3px;
    width: 100%;
  }

  /* Extra quarter subdivider lines (medium dark grey) */
  .subquarter-line {
    position: absolute;
    background-color: #555; /* medium dark grey */
    z-index: 1;
  }
  /* Each quarter is 8x8 cells. Each cell ~31px incl gap */
  /* Vertical quarter subdividers at 4 cells inside quarter (4 * 31px) */
  .subquarter-v-nw {
    left: calc(4 * 31px - 1px);
    top: 0;
    width: 2px;
    height: 50%;
  }
  .subquarter-v-ne {
    left: calc(8 * 31px + 4 * 31px - 1px);
    top: 0;
    width: 2px;
    height: 50%;
  }
  .subquarter-v-sw {
    left: calc(4 * 31px - 1px);
    top: 50%;
    width: 2px;
    height: 50%;
  }
  .subquarter-v-se {
    left: calc(8 * 31px + 4 * 31px - 1px);
    top: 50%;
    width: 2px;
    height: 50%;
  }
  /* Horizontal quarter subdividers at 4 cells inside quarter */
  .subquarter-h-nw {
    top: calc(4 * 31px - 1px);
    left: 0;
    height: 2px;
    width: 50%;
  }
  .subquarter-h-ne {
    top: calc(4 * 31px - 1px);
    left: 50%;
    height: 2px;
    width: 50%;
  }
  .subquarter-h-sw {
    top: calc(8 * 31px + 4 * 31px - 1px);
    left: 0;
    height: 2px;
    width: 50%;
  }
  .subquarter-h-se {
    top: calc(8 * 31px + 4 * 31px - 1px);
    left: 50%;
    height: 2px;
    width: 50%;
  }

  /* Controls styling */
  #controls {
    margin-top: 10px;
  }
  input, button {
    font-size: 16px;
    margin: 5px;
    padding: 5px 10px;
  }
  #aliquot-input {
    width: 400px;
    max-width: 90vw;
  }
</style>
</head>
<body>
<div id="container">
  <input type="text" id="aliquot-input" placeholder="Enter aliquot paths (e.g. NW 1/4, SE 1/4)" />
  <div id="controls">
    <button id="visualize">Visualize</button>
    <button id="reset">Reset</button>
    <button id="export-png">Export PNG</button>
    <button id="export-pdf">Export PDF</button>
  </div>
  <div id="grid"></div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/html2canvas/1.4.1/html2canvas.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script>
  const GRID_SIZE = 16;
  const MAX_LEVELS = 4;

  const QUARTER_POSITIONS = {
    NW: [0,0],
    NE: [0,1],
    SW: [1,0],
    SE: [1,1]
  };

  // For half positions (not changed here)
  const HALF_POSITIONS = {
    'NW': [0,0,8,8],
    'NE': [0,8,8,8],
    'SW': [8,0,8,8],
    'SE': [8,8,8,8]
  };

  const cellClickLevels = new Map();

  function initGrid() {
    const grid = document.getElementById('grid');
    grid.innerHTML = '';

    for (let r = 0; r < GRID_SIZE; r++) {
      for (let c = 0; c < GRID_SIZE; c++) {
        const div = document.createElement('div');
        div.classList.add('cell');
        div.id = `cell-${r}-${c}`;
        div.dataset.row = r;
        div.dataset.col = c;
        if (r === 0 || r === 8) div.classList.add('border-top');
        if (c === 0 || c === 8) div.classList.add('border-left');
        if (r === GRID_SIZE - 1) div.classList.add('border-bottom');
        if (c === GRID_SIZE - 1) div.classList.add('border-right');
        div.addEventListener('click', onCellClick);
        grid.appendChild(div);
      }
    }

    // Add main subgrid lines (black)
    ['subgrid-v1','subgrid-v2','subgrid-h1','subgrid-h2'].forEach(cls => {
      const line = document.createElement('div');
      line.className = `subgrid-line ${cls}`;
      grid.appendChild(line);
    });

    // Add extra quarter subdividers (medium dark grey)
    ['nw','ne','sw','se'].forEach(q => {
      const vLine = document.createElement('div');
      vLine.className = `subquarter-line subquarter-v-${q}`;
      grid.appendChild(vLine);

      const hLine = document.createElement('div');
      hLine.className = `subquarter-line subquarter-h-${q}`;
      grid.appendChild(hLine);
    });
  }

  function parseAliquots(input) {
    const parts = input.toUpperCase().split(',').map(p => p.trim());
    const paths = [];
    parts.forEach(part => {
      const tokens = part.split(/\s+/);
      const path = [];
      for (let i = 0; i < tokens.length - 1; i++) {
        if (QUARTER_POSITIONS[tokens[i]] && tokens[i+1] === '1/4') {
          path.push({ type: 'quarter', value: tokens[i] });
          i++;
        } else if (HALF_POSITIONS[tokens[i]] && tokens[i+1] === '1/2') {
          path.push({ type: 'half', value: tokens[i] });
          i++;
        }
      }
      if (path.length > 0) paths.push(path.reverse());
    });
    return paths;
  }

  function getCellsFromPath(path) {
    let regions = [{ row: 0, col: 0, size: GRID_SIZE }];
    path.forEach(part => {
      const newRegions = [];
      regions.forEach(({row, col, size}) => {
        const half = size / 2;
        if (part.type === 'quarter') {
          const [rMul, cMul] = QUARTER_POSITIONS[part.value];
          newRegions.push({ row: row + rMul * half, col: col + cMul * half, size: half });
        } else if (part.type === 'half') {
          const [rOff, cOff, rSize, cSize] = HALF_POSITIONS[part.value];
          for (let rr = 0; rr < rSize; rr++) {
            for (let cc = 0; cc < cSize; cc++) {
              newRegions.push({ row: row + rOff + rr, col: col + cOff + cc, size: 1 });
            }
          }
        }
      });
      regions = newRegions;
    });
    return regions.flatMap(({row, col, size}) => Array.from({ length: size }).flatMap((_, dr) =>
      Array.from({ length: size }).map((_, dc) => ({ row: row + dr, col: col + dc }))
    ));
  }

  function highlightCells(paths) {
    initGrid();
    paths.forEach(fullPath => {
      const cells = getCellsFromPath(fullPath);
      cells.forEach(({row, col}) => {
        const cell = document.getElementById(`cell-${row}-${col}`);
        if (cell) {
          cell.classList.add('selected');
        }
      });
    });
  }

  function getAliquotPathFromCell(row, col) {
    let size = GRID_SIZE;
    const path = [];
    for (let lvl = 0; lvl < MAX_LEVELS; lvl++) {
      size /= 2;
      const quadrantRow = Math.floor((row % (size*2)) / size);
      const quadrantCol = Math.floor((col % (size*2)) / size);
      for (const [name, [r, c]] of Object.entries(QUARTER_POSITIONS)) {
        if (r === quadrantRow && c === quadrantCol) {
          path.push(`${name} 1/4`);
          break;
        }
      }
    }
    return path.reverse().join(' ');
  }

  function onCellClick(e) {
    const row = +e.target.dataset.row;
    const col = +e.target.dataset.col;
    const key = `${row},${col}`;
    const currentLevel = cellClickLevels.get(key) || 0;
    if (currentLevel >= MAX_LEVELS) {
      cellClickLevels.delete(key);
      updateAliquotInput();
      return;
    }
    cellClickLevels.set(key, currentLevel + 1);
    updateAliquotInput();
  }

  function updateAliquotInput() {
    const input = document.getElementById('aliquot-input');
    const entries = [];
    for (const [key, level] of cellClickLevels.entries()) {
      const [row, col] = key.split(',').map(Number);
      let path = [];
      let size = GRID_SIZE;
      for (let lvl = 0; lvl < level; lvl++) {
        size /= 2;
        const quadrantRow = Math.floor((row % (size * 2)) / size);
        const quadrantCol = Math.floor((col % (size * 2)) / size);
        for (const [name, [r, c]] of Object.entries(QUARTER_POSITIONS)) {
          if (r === quadrantRow && c === quadrantCol) {
            path.push(`${name} 1/4`);
            break;
          }
        }
      }
      entries.push(path.reverse().join(' '));
    }
    input.value = entries.join(', ');
    highlightCells(parseAliquots(input.value));
  }

  document.getElementById('visualize').onclick = () => {
    highlightCells(parseAliquots(document.getElementById('aliquot-input').value));
  };

  document.getElementById('reset').onclick = () => {
    document.getElementById('aliquot-input').value = '';
    cellClickLevels.clear();
    initGrid();
  };

  document.getElementById('export-png').onclick = () => {
    const grid = document.getElementById('grid');
    html2canvas(grid).then(canvas => {
      const link = document.createElement('a');
      link.download = 'plss-grid.png';
      link.href = canvas.toDataURL('image/png');
      link.click();
    }).catch(err => alert('Error exporting PNG: ' + err.message));
  };

  document.getElementById('export-pdf').onclick = async () => {
    const grid = document.getElementById('grid');
    const { jsPDF } = window.jspdf;
    try {
      const canvas = await html2canvas(grid);
      const imgData = canvas.toDataURL('image/png');
      const pdf = new jsPDF({ orientation: 'portrait', unit: 'pt', format: 'letter' });
      const pdfWidth = pdf.internal.pageSize.getWidth();
      const pdfHeight = pdf.internal.pageSize.getHeight();
      const imgProps = pdf.getImageProperties(imgData);
      const imgWidth = pdfWidth * 0.9;
      const imgHeight = (imgProps.height * imgWidth) / imgProps.width;
      pdf.addImage(imgData, 'PNG', (pdfWidth - imgWidth) / 2, 40, imgWidth, imgHeight);
      pdf.save('plss-grid.pdf');
    } catch (err) {
      alert('Error exporting PDF: ' + err.message);
    }
  };

  window.onload = initGrid;
</script>
</body>
</html>
